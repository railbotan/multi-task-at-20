# Параллелизм и асинхронность
## IO-bound. Проверяем ссылки на страницах Википедии
### синхронно в 1 поток:

Время выполнения:

![image](/images/1.bmp)
Заняло около 22 минут

Диспетчер задач:

![image](/images/2.bmp)


### С помощью ThreadPoolExecutor:
*  5 воркеров

Время выполнения:

![image](/images/3.bmp)
Около 5 минут

Диспетчер задач:

![image](/images/4.bmp)

* 10 воркеров:

Время выполнения:

![image](/images/5.bmp)
около 4 минут

Диспетчер задач:

![image](/images/6.bmp)

* 100 воркеров:

Время выполнения:

![image](/images/7.bmp)
около 3 минут

Диспетчер задач:

![image](/images/8.bmp)

### Вывод:
Использование памяти значительно разнится в сравнение с одним потоком, если сравнивать с разными значениями(5, 10, 100), то разница практически не заметна. При использовании ThreadPoolExecutor уменьшилось время выполнения.

## CPU-bound. Генерируем монетки

* На 1 ядре:

Время выполнения:

![image](/images/9.bmp)
около 2 минут

Диспетчер задач:

![image](/images/10.bmp)

* 2 воркера:

Время выполнения:

![image](/images/11.bmp)
около 2 минут

Диспетчер задач:

![image](/images/12.bmp)

* 4 воркера:

Время выполнения:

![image](/images/13.bmp)
около 2 минут

Диспетчер задач:

![image](/images/14.bmp)

* 5 воркеров:

Время выполнения:

![image](/images/15.bmp)
меньше минуты

Диспетчер задач:

![image](/images/16.bmp)

* 10 воркеров:

Время выполнения:

![image](/images/17.bmp)
около минуты

Диспетчер задач:

![image](/images/18.bmp)

* 100 воркеров:
* ошибка

![image](/images/19.bmp)

### Вывод:
При использовании одного ядра нагрузка была несильной. При использовании ProcessPoolExecutor время сократилось. При увеличении воркеров нагрузка на ЦП немного увеличивалась. Есть некоторая погрешность в значениях, так как нагрузка была неоднозначной.
